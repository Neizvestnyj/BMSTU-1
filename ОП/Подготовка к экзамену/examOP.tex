% cd "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"&&cp -r "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"img/ "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"conf/&&cp "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"examOP.tex "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"conf/&&cd "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"conf/&&/usr/local/texlive/2022/bin/universal-darwin/xelatex --shell-escape examOP.tex&&cp "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"/conf/examOP.pdf "/Users/pluttan/Desktop/_Сем1/BMSTU-1/ОП/Подготовка к экзамену/"/

\include{/Users/pluttan/Documents/forMyDocs/preamb.tex}
\include{/Users/pluttan/Documents/forMyDocs/preambMisha.tex}
\newcommand{\hbook}[1]{{\begin{center}\textit{Иванова Г.С. Основы программирования 2002, стр. #1}\end{center}}}
\newcommand{\hprez}[2]{\begin{center}\textit{Иванова Г.С. Курс Основы программирования, през. #1, сл. #2}\end{center}}

\begin{document}
% \end{document}
\dotitle{Подготовка к экзамену}{Основы программирования}
\toc

\section{Теоритическая часть}

%================================
%          Вопрос 1
%================================

\subsection{Синтаксис  и  семантика  языков  программирования.  Алфавит  языка  Pascal.  Описание синтаксиса языка: синтаксические диаграммы. Примеры. }

\begin{myquote}
\hbook{28 - 30}

\hprez{1}{9, 26}
\end{myquote}
\large
{\bf{Синтаксис}}
 - совокупность правил, определяющих допустимые конструкции (слова, предложения) языка, его форму. «Защищенный» синтаксис предполагает, что предложения языка строятся по правилам, которые позволяют автоматически выявлять большой процент ошибок в программах.

{\bf{Семантика}}
 - совокупность правил, определяющих смысл синтаксически корректных конструкций языка, его содержание. Ясная или «интуитивно-понятная» семантика – семантика, позволяющая без большого труда определять смысл программы или «читать» ее.

{\bf{Алфавит языка Паскаль  }}

\begin{enumerate}
\item Латинские буквы без различия строчных и прописных;
\item Арабские цифры: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
\item Шестнадцатеричные цифры: 0..9, а..f или A..F;
\item Специальные символы: + - * / = := ; и т. д.;
\item Служебные слова: do, while, begin, end и т. д.
\end{enumerate}

{\bf{Описание синтаксиса языка}}

Включает определение алфавита и правил построения различных конструкций языка из символов алфавита и более простых конструкций. Для этого обычно используют либо форму Бэкуса-Наура (БНФ), либо синтаксические диаграммы.

{\bf{Синтаксические диаграммы}}
отображают правила построения конструкций в более наглядной форме.
На такой диаграмме:
\begin{itemize}
\item символы алфавита изображают блоками в овальных рамках;
\item названия конструкций в прямоугольных рамках;
\item правила построения конструкций – в виде линии со стрелками на концах;
\item разветвление линии означает, что при построении конструкции есть варианты. 
\end{itemize}
Пример: синтаксическая диаграмма, иллюстрирующая первые два правила описания конструкции <целое>
\image{exm1.png}{140}


%================================
%          Вопрос 2
%================================

\newpage\subsection{Представление  данных  в  языке  Pascal:  константы  и  переменные.  Классификация  скалярных типов данных, их внутреннее представление, операции над ними. Примеры.} 

\begin{myquote}
\hbook{31 - 40}

\hprez{1}{27 - 43}
\end{myquote}

{\bf{Константы}} – определяются один раз и не изменяются во время выполнения программы.
Используют следующие типы констант:
\begin{enumerate}
    \item Целые и вещественные десятичные числа;
    \item Шестнадцатеричные числа;
    \item Логические константы;
    \item Символьные константы – (записываются либо в апострофах, либо в виде соответствующих кодов по таблице ASCII);
    \item Строки символов – записываются в апострофах;
    \item Конструкторы множеств;
    \item Нулевой адрес – nil.
\end{enumerate}

Константы используются в двух формах: 
\begin{itemize}
    \item {\bf{Литерал}} – представляет собой значение константы, записанное непосредственно в программе;
    \item {\bf{Поименованные константы}} объявляются в инструкции раздела описаний const. Обращение к ним осуществляется по имени (идентификатору).
\end{itemize}
\image{exm3.jpg}{90}

{\bf{Переменные}} – поименованные значения, которые могут изменяться в процессе выполнения программы. Их объявление выполняют в разделе описаний программы, причем указывается не только идентификатор переменной, но и ее тип. Обращение к переменным также осуществляют по идентификатору.

{\bf{Тип переменной}} – определяет возможный набор значений данной переменной, размер ее внутреннего представления и множество операций, которые могут выполняться над переменной.

\image{exm4.jpg}{110}

Простые (скалярные) типы описывают упорядоченные наборы значений. Они делятся на {\bf порядковые} и {\bf вещественные}.

- {\bf {Группа порядковых типов}} объединяет типы переменных, набор значений которых конечен.

- {\bf {Группа вещественных типов}} объединяет типы с условно бесконечным набором значений.
\image{exm5.jpg}{300}

\begin{itemize}

\item {\bf{Стандартные типы}}

{\normalsize
\begin{center}
\begin{tabular}{ | c | c | c | c | }
\hline
Название & Обозначение & Диапазон значений & Длина внутреннего представления, байт\\
\hline
Целое & Integer & -32768..32767 & 2 (со знаком) \\
\hline
Короткое целое & ShortInt & -128..127 & 1 (со знаком) \\
\hline
Длинное целое & LongInt & $-2^{31}$..$2^{31}$ -1 & 4 (со знаком) \\
\hline
Байт & Byte & 0..255 & 1 (без знака) \\
\hline
Слово & Word & 0..65535 & 2 (без знака) \\
\hline
Логический & Boolean & True, false & 1 \\ 
\hline
Символьный & Char & Символы по таблице ASCII & 1\\
\hline
\end{tabular}
\end{center}
}

*{\bf{Логический тип}} Boolean включает два значения – true(1) и false(0), но в памяти значения данного типа занимают целый байт;

*{\bf{Символьный тип}} char определяет набор символов по таблице ASCII. 

\item {\bf{Перечисляемый тип (перечисление)}} 
– формируется из значений, определенных программистом при объявлении типа. Перечень задают через запятую в круглых скобках. Во внутреннем представлении значения перечисляемого типа кодируются целыми числами, начиная с нуля. Например:


Var D : (Mon, The, Wed, Thu, Fri, Sat, Sun);   \{переменная D принимает одно из перечисленных значений\}

Mon = 0; The = 1 ... Sun = 6;

\item {\bf{Отрезок}}
– определяется как диапазон значений некоторого уже определенного типа. Например: 

Var D : 1..31;

\item {\bf{Вещественные типы}}
{\normalsize
\begin{center}
    \begin{tabular}{ | c | c | c | c | c | }
    \hline
Название & Обозначение & Кол-во десятичных  & Диапазон изменения  & Длина внутреннего \\
&&значащих цифр&порядка&представления, байт\\
    \hline
    Вещественный & Real & 11..12 & -39..+38 & 6\\
    \hline
    Одинарной точности & Single & 7..8 & -45..+38 & 4\\
    \hline
    Двойной точности & Double & 15..16 & -324..+308 & 8\\
    \hline
    Расширенный & Extended & 19..20 & -4951..4932 & 10\\
    \hline
    Большое целое & Comp & 19..20 & $-2^{63}+1.. 2^{63}-1$ & 8 \\
    \hline
    \end{tabular}
\end{center}
}
\end{itemize}
\vspace*{10pt}
{\bf{Операции}}
\begin{enumerate}

\item {\bf{Арифметические операции}} – применяют к вещественным и целым константам и переменным:
+,  -, *, 

/  - \{вещественное деление\},

div  - \{целочисленное деление\}, 

mod  - \{остаток от деления\}

*приоритет операций рассчитывается как в математике (+ скобки).

\image{exm6.jpg}{90}

\item {\bf{Операции отношения (больше, меньше, равно и т.д.)}} – применяют к числам, символам, строкам – в результате получают логическое значение:

< \{меньше\}, > \{больше\}, = \{равно\}, 

<> \{не равно\}, <= \{меньше или равно\}, >= \{больше или равно\}

\item {\bf{Логические операции}} – применяют к логическим значениям – результат логическое значение: not, and, or, xor

\item {\bf{Поразрядные операции}} – выполняются поразрядно, применяют к целым, результат – целое число:

not, and, or, xor, shr  - \{сдвиг вправо\}, shl  - \{сдвиг влево\} 
\end{enumerate}


%================================
%          Вопрос 3
%================================

\newpage\subsection{Совместимость типов данных и операции преобразования типов. Примеры. }

\begin{myquote}
\hbook{41 - 42}
    
\hprez{1}{43, 45}
\end{myquote}

По правилам {\bf{совместимы}}:
\begin{enumerate}
    \item все целые типы между собой;
    \item все вещественные типы между собой;
    \item отрезок базового типа и базовый тип;
    \item два отрезка одного и того же базового типа;
    \item символ и строка.
\end{enumerate}

Для несовместимых типов результата и переменной, в которую его необходимо занести, при выполнении присваивания необходимо явное преобразование типов, например, посредством специальных функций:
\begin{itemize}
\item trunc(<Вещественное выражение>) – преобразует вещественное число в целое, отбрасывая дробную часть.

\item round(< Вещественное выражение>) – округляет вещественное число до целого по правилам арифметики.

Пример:   trunc(4.5) = 4,    round(4.5) = 5 

\item ord(<Порядковое выр.>) – преобразует значение в его номер.
Пример:   ord(’A’)  = 65.

\item chr(<Ц. выр.>) – преобразует номер символа в символ.
Пример:   chr(65) = ’A’.
\end{itemize}
\lstinputlisting[language=Pascal]{../Examples/b3_1.pas}


%================================
%          Вопрос 4
%================================

\newpage\subsection{Присваивание, условный оператор, оператор выбора. Синтаксис операторов, их особенности и примеры использования. }

\begin{myquote}
\hbook{40 – 42, 50 - 57}
        
\hprez{1}{43}
\hprez{2}{2 - 7}
\end{myquote}

{\bf{Оператор присваивания}}

- используется для изменения значений переменных.

Корректное выполнение оператора предполагает, что результат вычисления и переменная правой части одного типа или совместимы по типу.

\image{exm7.jpg}{35}

{\bf{Условный оператор (Оператор условной передачи управления)}}

- используется при обработке вариантов вычислений и реализует конструкцию ветвления.

\image{exm8.jpg}{45}

{\textit{примечание:}}
В каждой ветви допускается запись одного оператора (в том числе и другого if) или составного оператора. 
Составным оператором называют последовательность 
операторов, заключенную в операторные скобки begin...end. Операторы последовательности отделяют друг от друга точкой с запятой «;». Перед end 
точку с запятой можно не ставить. Перед else точка с запятой не ставится 
никогда, так как в этом случае запись условного оператора продолжается.

{\bf{Оператор выбора}}

- позволяет программировать несколько вариантов решения. Используется для реализации нескольких альтернативных вариантов действий, каждый из которых соответствует своим значениям некоторого параметра.

\image{case.jpg}{90}


\lstinputlisting[language=Pascal]{../Examples/b4_1.pas}


%================================
%          Вопрос 5
%================================

\newpage\subsection{Операторы циклов языка Pascal. Синтаксис операторов, их особенности и примеры использования. }

\begin{myquote}
\hbook{58 - 62}
        
\hprez{2}{10 - 13}
\end{myquote}

{\bf{Циклы бывают:}} 
\begin{itemize}
\item {\bf{Cчетный цикл}} – цикл, количество повторений которого известно или можно посчитать. Выход из такого цикла программируется по счетчику.

\item {\bf{Итерационный цикл}} – цикл, количество повторений которого неизвестно или считается неизвестным при построении цикла. 
Выход из цикла программируется по выполнению или нарушению условия.

\item {\bf{Поисковый цикл}} имеет два выхода – «нашли» либо «перебрали все и не нашли».
\end{itemize}

{\bf{Цикл while (цикл пока)}}
\image{while.jpg}{30}


{\bf{Цикл repeat..until (цикл до)}}
\image{repeat.jpg}{70}


{\bf{Цикл for (счетный цикл)}}
\image{for.jpg}{70}


\lstinputlisting[language=Pascal]{../Examples/b5_1.pas}


%================================
%          Вопрос 6
%================================

\newpage\subsection{Поисковый цикл. Неструктурная и структурная реализации поискового цикла. }

\begin{myquote}
\hbook{69 - 76}
\end{myquote}

{\bf{Поисковые циклы}} – циклические процессы поиска некоторой информации в таблицах, выход из которых происходит при нахождении необходимой информации или по завершению процесса поиска, если необходимая информация не найдена.

{\bf{Неструктурная реализация}} включает неструктурные передачи управления: оператор безусловной передачи управления и специальные процедуры.

{\bf{Структурная реализация}}, наоборот, не включает такие передачи управления.

{\bf{Оператор безусловной передачи управления}} – этот оператор передает управление в точку, определенную специальной меткой.
Все метки в программе должны быть описаны инструкцией объявления меток label. 

Метка ставится перед любым выполняемым оператором программы, причем на один оператор можно поставить несколько меток, например:

Label Ml, М2, М3;...

Ml:М2:МЗ:х:=х+1;

goto Ml;

Неструктурную передачу управления также осуществляют ряд процедур:
\begin{itemize}
\item Break — реализует выход из цикла любого типа.

\item Continue — осуществляет переход на следующую итерацию цикла, игнорируя оставшиеся до конца тела цикла операторы.

\item Halt (<Код завершения>) — осуществляет выход из программы, возвращая операционной системе заданный код завершения. 

Считается, что программа завершилась нормально, если код завершения равен нулю. Возвращение кода завершения, отличного от нуля, обычно означает, что программа завершена по обнаружении каких-либо ошибок. Коды завершения назначаются программистом, а информация о них помещается в программную документацию.



\item Exit — осуществляет выход из подпрограммы. Если процедура использована в основной программе, то она выполняется аналогично Halt.

\end{itemize}

пример (поиск информации в массиве, см. листинг ниже): 

\lstinputlisting[language=Pascal]{../Examples/b6_1.pas}


%================================
%          Вопрос 7
%================================

\newpage\subsection{Массивы языка Pascal. Описание, внутреннее представление, операции над массивами и 
их элементами. Примеры. }

\begin{myquote}
\hbook{77 - 86}
\hprez{3}{2 - 11}
\end{myquote}

{\bf{Массив}} – это упорядоченная совокупность однотипных данных. Каждому элементу массива соответствует один или несколько индексов порядкового типа, определяющих положение элемента в массиве.

\image{array.jpg}{70}

{\bf{Тип индекса}} – порядковый – определяет доступ к элементу. 
{\bf{Тип элемента}} – любой кроме файла, в том числе массивы, строки и т.п.
Массив в памяти не может занимать более 2 Гб. 


Массивы бывают {\bf{одномерными}} и {\bf{многомерными}}, в зависимости от количества измерений (индексов):
\begin{enumerate}
\item У одномерного массива одно измерение (обращение к его элементам производится с помощью одного индекса);

\item У многомерного массива несколько измерений. Фактически это «массив массивов ...».
\end{enumerate}

{\bf{Внутреннее представление массивов}}

В памяти элементы массива хранятся по порядку, друг за другом, с некоторым шагом. Этот шаг равен числу байт, которые необходимы на запись одного элемента массива (у всех элементов массива – один тип).

{\bf{Операции над массивами}}

\begin{enumerate}
\item Операция присваивания (только для массивов одного типа):

Пример:

\begin{lstlisting}[language=Pascal]
Var a, b:array[boolean] of real;

... 

a:=b; 
\end{lstlisting}

\item Доступ к элементу массива

\begin{lstlisting}[language=Pascal]
Var a : array[1..10] of integer;

... 

	a[i] := 1;  {*1} 
	b[2] := 2;  {*2}
\end{lstlisting}
\{*1\} Прямой доступ: значение индекса - литерал;

\{*2\} Косвенный доступ позволяет реализовать последовательную обработку элементов массивов.

\item Ввод/вывод массивов осуществляется поэлементно.

\end{enumerate}

\lstinputlisting[language=Pascal]{../Examples/b7_1.pas}


%================================
%          Вопрос 8
%================================

\newpage\subsection{Строки языка Pascal. Описание, внутреннее представление, операции над строками и их 
элементами. Примеры. }

\begin{myquote}
    \hbook{113 - 127}
            
    \hprez{3}{12 - 22}
\end{myquote}

{\bf{Строка}} – последовательность символов.

\image{string.jpg}{60}

*Целое – максимальная длина строки.

{\bf{Внутреннее представление}}
\image{maxCountOfChar.jpg}{90}

{\bf{Операции над строками}}
\begin{enumerate}
\item Присваивание строк:

\begin{lstlisting}[language=Pascal]
 	S1:=′ABCD′;
	S1:=S2;
	S1:=′A′;
	S1:=′′;{пустая строка}
\end{lstlisting}
    
\item Обращение к элементу:

	S1[5] - прямое;

	S1[i] - косвенное.

\item Конкатенация (сцепление) строк:

\begin{lstlisting}[language=Pascal]
	St:=St + ’A’;
	St:=’A’ + ’B’;
\end{lstlisting}

\item Операции отношения – выполняется попарным сравнением кодов символов, результат определяется по отношению кодов первых различных символов:

\begin{lstlisting}[language=Pascal]
	b:= S1 > S2;
	’T’ < ’Ta’
\end{lstlisting}

\item Ввод-вывод строк:

\begin{lstlisting}[language=Pascal]
ReadLn(S1);
WriteLn(S1);
\end{lstlisting}

\end{enumerate}

\vspace*{10pt}
{\bf{Стандартные процедуры и функции}}

\begin{enumerate}
\item Функция Length(st):word – возвращает длину строки st: 

\begin{lstlisting}[language=Pascal]
	n:=Length(st1);  
\end{lstlisting} 

\item Процедура Delete(st, index, count) – удаляет count символов строки st, начиная с символа с номером index:

\begin{lstlisting}[language=Pascal]
    S1: = ′dddddsssssfffff′; 
	Delete(S1,6,5);  
\end{lstlisting} 

\item Процедура Insert(St2,St1,index) – вставляет подстроку символов St2 в строку St1, начиная с символа с номером index:

\begin{lstlisting}[language=Pascal]
	S1 = ′dddddddddd′;
	S2 = ′аааааа′ ;
	Insert(S2,S1,6);      
	Insert(′Pas’,S1,6);      
\end{lstlisting} 

\item Процедура Str(x[:w[:d]],St) – преобразует результат выражения x, в строку st, содержащую запись этого числа в виде последовательности символов (как при выводе). 

\begin{lstlisting}[language=Pascal]
	x:=-5.67;
	Str(x:7:3,s1);
\end{lstlisting} 

\item Процедура Val(St,x,Code) – преобразует строку St с записью числа в виде последовательности символов во внутреннее представление целого или вещественного числа и помещает его в переменную x.  В целочисленной переменной Code процедура возвращает код ошибки

\item Функция Copy(St,index,count):string – возвращает фрагмент строки St, длиной count символов, начиная с символа с номером index:

\begin{lstlisting}[language=Pascal]
 	S1 = ′qqqEEEEEEuuuuu′;
 	S:= Copy(S1,4,6);     
\end{lstlisting} 

\item Функция Pos(St2,St1):integer – возвращает номер позиции первого вхождения подстроки St2 в строку St1. Если вхождение не найдено, то функция возвращает 0:

\begin{lstlisting}[language=Pascal]
	S1 = ′qqqEEррEEuuuuu′;
 	i:= Pos(′EE′,S1);     
\end{lstlisting} 

\item Функция UpCase(ch):char – возвращает символ, соответствующий символу верхнего регистра для ch, если таковой имеется, либо сам символ ch, если для него не определен символ верхнего регистра.

\end{enumerate}

\lstinputlisting[language=Pascal]{../Examples/b8_1.pas}


%================================
%          Вопрос 9
%================================

\newpage\subsection{Множества  языка  Pascal.  Описание,  внутреннее  представление,  операции  над  множествами и их элементами. Примеры. }

\begin{myquote}
    \hbook{127 - 135}
            
    \hprez{3}{23 - 28}
\end{myquote}

{\bf{Множество}} – неупорядоченная совокупность неповторяющихся элементов.

{\bf{Тип элементов}} – порядковый, кроме Word, Integer, SmallInt, LongInt. Количество элементов не должно превышать 256.

{\bf{Конструкторы множеств}} – константы множественного типа:
\begin{itemize}

\item $[$$]$ – пустое множество;
\item $[$2,3,5,7,11$]$ – множество чисел;
\item $[$’a’,’d’,’f’,’h’$]$ – множество символов;
\item $[$1,k$]$ – множество чисел, переменная k должна содержать число;
\item $[$2..100$]$ – множество содержит целые числа из указанного интервала;
\item $[$k..2*k$]$ – интервал можно задать выражениями;
\item $[$red,yellow,green$]$ - множество перечисляемого типа

\end{itemize}

{\bf{Инициализация множеств при объявлении:}}
\begin{lstlisting}[language=Pascal]
	Type setnum = set of byte;
	Var S:setnum = [1..10]; 
\end{lstlisting}

{\bf{Операции над множествами}}
\begin{enumerate}
\item Присваивание:

	A:=B;
	A:=[];

\item Объединение, пересечение и дополнение:

\begin{itemize}
\item А+B (A $\cup$ B) – объединение  множеств А и B – множество, состоящее из элементов, принадлежащих множествам А и B
\item А*B (A $\cap$ B) – пересечение множеств А и B – множество, состоящее из элементов, принадлежащих одновременно и множеству А и  множеству B.
\item А-B (A / B) – дополнение  множества А до B – множество, состоящее 	из тех элементов множества А, которые не принадлежат  множеству B.
\end{itemize}

\image {OPD.jpg}{150}

\item Операции отношения:

А = B – проверка совпадения множеств А и B (если совпадают – true).

А <> B – проверка не совпадения множеств А и B (не совпадают – true).

А <= B – проверка нестрогого вхождения A в B (если входит – true).

А > B – проверка строгого вхождения B в A (если входит – true). 

\item Проверка вхождения элемента во множество:
 
\item Значения множественного типа нельзя вводить и выводить!

\end{enumerate}
Примеры:
\begin{lstlisting}[language=Pascal]
[1,2]+[3,4] = [1,2,3,4];
[1..10]*[3,8,9,15,23,45] = [3,8,9];
[1..15]-[3,8,9,15,23,45] = [1,2,4..7,10..14];
[red,blue,green,black]*[blue,magenta,yellow] = [blue]
\end{lstlisting}

{\bf{Внутреннее представление}}

\image {SetIntRep.jpg}{190}


\lstinputlisting[language=Pascal]{../Examples/b9_1.pas}


%================================
%          Вопрос 10
%================================

\newpage\subsection{Записи языка Pascal. Описание, внутреннее представление, операции над записями и их 
элементами. Примеры. }

\begin{myquote}
    \hbook{136 - 143}
            
    \hprez{3}{33 - 38}
\end{myquote}

{\bf{Запись}} – это структура данных, образованная фиксированным числом разнотипных компонентов, называемых полями записи.

\image{Record.jpg}{90}

{\bf{Фиксированная часть}}:

\image{intend.jpg}{90}

{\bf{Операции над записями}}:

\begin{enumerate}
\item Присваивание записей одного типа:

\begin{lstlisting}[language=Pascal]
	Var A,B: record Day:1..31; Month: 1..12; Year: word; end;
	A:=B;
\end{lstlisting}

\item Доступ к полям записи:
\begin{itemize}

\item {\bf{Точечная нотация}}:

\image{dotNotation.jpg}{55}    

\begin{lstlisting}[language=Pascal]
    A.Day := 21; {dot notation}
\end{lstlisting}

\item {\bf{Оператор доступа}}:

\image{with.jpg}{60}

\begin{lstlisting}[language=Pascal]
    with A do Day := 21; {Access operator}
\end{lstlisting}

\end{itemize}

\item Ввод и вывод записей осуществляется по полям.

\end{enumerate}
    
{\bf{Вариантная часть}}

\image{caseOfRecord.jpg}{140}

- может содержать несколько альтернатив, в каждой из которых задается список полей, присущих данному варианту. Каждой альтернативе предшествует константа, идентифицирующая соответствующий вариант.


\lstinputlisting[language=Pascal]{../Examples/b10_1.pas}


%================================
%          Вопрос 11
%================================

\newpage\subsection{Процедуры и функции. Определение, описание, особенности. Примеры. }

\begin{myquote}
    \hbook{144 - 150}
            
    \hprez{4}{2 - 3}
\end{myquote}

{\bf{Процедуры и функции}} – самостоятельные фрагменты программы, соответствующим образом оформленные и вызываемые по имени (программные блоки).

Программный блок оформляется следующим образом:
\image{zag11.jpg}{40}

{\bf{Процедура}}
\image{procedure.jpg}{60}

{\bf{Функция}}
\image{function.jpg}{60}

{\bf{Особенности процедур}}

\begin{itemize}
\item могут иметь несколько результатов, или не иметь их вовсе. Результаты могут быть любого типа (осуществляется с помощью передачи параметров по ссылке).

\item команда вызова процедуры – отдельная команда, которая употребляется самостоятельно.
\end{itemize}

{\bf{Особенности функций}}
\begin{itemize}

\item имеет только один результат, тип которого указывается в объявлении функции. Этот результат возвращается функцией в точку вызова (никто не мешает передавать в функцию параметры по ссылке, по аналогии с процедурами, но тогда нет смысла использовать функцию).

\item обращение к функции может использоваться как компонент выражения соответствующего типа.
\end{itemize}



\lstinputlisting[language=Pascal]{../Examples/b11_1.pas}


%================================
%          Вопрос 12
%================================

\newpage\subsection{Способы передачи данных в подпрограмму на языке Pascal. Примеры. }

\begin{myquote}
    \hbook{145 - 147}
            
    \hprez{4}{5 - 9}
\end{myquote}

Из основной программы данные могут быть получены:

\begin{enumerate}
\item	{\bf{Неявно}} – с использованием глобальных констант и переменных;
\item	{\bf{Явно}} – через параметры.
\end{enumerate}

{\bf{Неявная передача данных}}

Каждой подпрограмме доступны все ресурсы программного блока, в разделе описаний которого эта подпрограмма объявлена. Однако в обратную сторону это не работает: локальные ресурсы, объявленные в разделе описаний подпрограммы, из программного блока, в разделе описания которого она определена, не доступны. Если имя одного из локальных ресурсов подпрограммы совпадет с именем одного из глобальных ресурсов программного блока, в разделе описания которого определена подпрограмма, то глобальный ресурс будет недоступен (он перекроется локальным).

{\bf{Недостатки неявной передачи данных}}:

\begin{enumerate}
    \item жестко связывает подпрограмму и данные;
    \item приводит к большому количеству ошибок.
\end{enumerate}

{\bf Передача данных через параметры}

Список параметров описывается в заголовке (объявлении) подпрограммы.
 
\image{listOfParameters.jpg}{90}

Передача данных в параметры осуществляется тремя способами:
\begin{enumerate}
    \item	{\bf Как значения} -  в подпрограмму передаются копии значений параметров, и никакие изменения этих копий не повлияют на оригиналы (изменения не возвращаются в вызывающую подпрограмму)
    \item	{\bf Как переменные} – в подпрограмму передаются адреса фактических параметров, соответственно все изменения этих параметров в подпрограмме на самом деле происходят с переменными, переданными в качестве фактических параметров; такие параметры при описании помечаются служебным словом var; в этом случае нельзя использовать литералы
    \item	{\bf Как неизменяемые переменные (именованные константы)} – в подпрограмму, так же как и в предыдущем случае, передаются адреса фактических параметров, но при попытке изменить значение параметра компилятор выдаст сообщение об ошибке; такие параметры при описании помечаются служебным словом const
\end{enumerate}



%================================
%          Вопрос 13
%================================

\newpage\subsection{Локальные и глобальные переменные, законы «видимости» идентификаторов. Примеры. }

\begin{myquote}
    \hbook{145}
    \hprez{4}{4}

\end{myquote}

{\bf{Локальная переменная}} - переменная, объявленная внутри какой-либо функции или процедуры. Областью видимости локальных переменных является тело функции или процедуры, в которой эта переменная объявлена. Локальная переменная может быть проинициализирована константой или выражением, соответствующими ее типу.

{\bf{Глобальная переменная}} - переменная, объявленная за пределами всех функций и процедур. Областью видимости глобальных переменных является вся программа.


\image {LocalGlobal.jpg}{120}

{\bf{Законы видимости идентификаторов}}

\begin{enumerate}
    
\item В подпрограмме можно обращаться к внешним идентификаторам, если в ней нет локального идентификатора с тем же именем;
\item Если таковой имеется, то он перекрывает внешний идентификатор;
% TODO: check this)
\item Однако к {\bf внешнему идентификатору} можно будет обратиться из подпрограммы, если дописать к нему спереди имя содержащей его программы.

\end{enumerate}

\lstinputlisting[language=Pascal]{../Examples/b12&&13_1.pas}


%================================
%          Вопрос 14
%================================

\newpage\subsection{Формальные и фактические параметры подпрограмм языка Pascal. Примеры. }

\begin{myquote}
    \hbook{146}
    \hprez{4}{7}
\end{myquote}

Параметры, описанные в заголовке – {\bf формальные}. 

При вызове подпрограммы необходимо определить {\bf фактические} значения этих параметров – аргументы (константы и переменные).

Формальные и фактические параметры должны соответствовать по количеству, типу и порядку.


%================================
%          Вопрос 15
%================================

\newpage\subsection{Параметры-строки, параметры-массивы. Примеры. }

\begin{myquote}
    \hprez{4}{14}
\end{myquote}

Структурные типы параметров (массивы, строки, множества, записи, указатели, файлы) должны быть {\bf предварительно объявлены}.

\lstinputlisting[language=Pascal]{../Examples/b15_1.pas}


%================================
%          Вопрос 16
%================================

\newpage\subsection{Принципы разработки универсальных подпрограмм: «открытые» массивы. Примеры. }

\begin{myquote}
    \hbook{159 - 162}
            
    \hprez{4}{21 - 23}
\end{myquote}

{\bf Открытый массив} – конструкция описания типа массива без указания типа индексов. Используется при объявлении формальных параметров.

Индексы открытых массивов всегда начинаются с 0;

Размер такого массива можно:
\begin{itemize}
\item передать через дополнительный параметр;
\item получить, используя функцию High(<Идентификатор массива>).
\end{itemize}

Чтобы в программе выделить память под открытый массив, следует воспользоваться процедурой setlength, которая принимает два фактических параметра – имя открытого массива и устанавливаемое количество элементов в нем. В результате работы setlength в памяти выделяется столько байт, сколько необходимо для хранения n-го количества элементов определенного типа. Чтобы освободить выделенную память, используется nil.


\lstinputlisting[language=Pascal]{../Examples/b16_1.pas}


%================================
%          Вопрос 17
%================================


\newpage\subsection{Принципы разработки универсальных подпрограмм:  нетипизированные параметры, параметры процедурного типа. Примеры. }


\begin{myquote}
    \hbook{162 - 168}
            
    \hprez{4}{24 - 35}
\end{myquote}

{\bf Нетипизированные параметры} – параметры-переменные, тип которых при объявлении не указан.

Для приведения нетипизированного параметра к определенному типу можно использовать:

\begin{enumerate}
\item автоопределенное преобразование типов:
\begin{lstlisting}[language = pascal]
 	Procedure Proc(Var a); ...
  	 ...b := Integer(а) + 10; ...
\end{lstlisting}

\item наложенное описание переменной определенного типа:
\begin{lstlisting}[language = pascal]
 	Procedure Proc(Var a); ...
    Var r:real absolute a;...
\end{lstlisting}
\end{enumerate}

{\bf{Параметры процедурного типа}} используются для передачи в подпрограмму имен процедур и функций. Для объявления процедурного типа используется заголовок подпрограммы, в котором отсутствует имя:

\begin{lstlisting}[language = pascal]
	Type proc = procedure (a,b,c:real;Var d:real);
        func = function(x:real):real;
\end{lstlisting}

Значениями переменных процедурных типов являются идентификаторы процедур и функций с соответствующими заголовками:

\begin{lstlisting}[language = pascal]
	Var  f:func;
	...
	f:=fun1;...
\end{lstlisting}



%================================
%          Вопрос 18
%================================

\newpage\subsection{Структура модуля языка Pascal. Законы видимости идентификаторов. Доступ к «перекрытым» идентификаторам. Примеры. }


\begin{myquote}
    \hbook{156 - 159}
            
    \hprez{4}{16 - 20}
\end{myquote}

{\bf Модуль} – это автономно компилируемая коллекция программных ресурсов, предназначенных для использования другими модулями и программами.

{\bf Ресурсы} – переменные, константы, описания типов и подпрограммы.

Все ресурсы, определенные в модуле, делят на:

\begin{enumerate}
\item внешние – предназначенные для использования другими программами и модулями.
\item внутренние – предназначенные для использования внутри модуля.
\end{enumerate}

Структура модуля:

{\bf Unit} <Имя модуля (= имя файла, в котором он описан)>;

{\bf Interface }

       <Интерфейсная секция>

{\bf Implementation}

       <Секция реализации>

{\bf [Initialization}

       <Секция инициализации>

{\bf [Finalization}

       <Секция завершения>]]
       
{\bf End. }

{\bf Правило видимости имен ресурсов модуля}

\begin{itemize}
\item Ресурсы модуля перекрываются ресурсами программы и ранее указанными модулями.

\item Для доступа к перекрытым ресурсам модуля используют точечную нотацию: 

	<Имя модуля>.<Имя ресурса>

\end{itemize}

\lstinputlisting[language=Pascal]{../Examples/b18_1.pas}


%================================
%          Вопрос 19
%================================

\newpage\subsection{Рекурсия.  Виды  рекурсии.  Особенности  программирования. Достоинства  и  недостатки. 
Пример. }

\begin{myquote}
    \hbook{168 - 179}
            
    \hprez{4}{36 - 53}
\end{myquote}


{\bf Рекурсия} – организация вычислений, при которой процедура или функция обращаются к самим себе.

Различают {\bf явную} и {\bf косвенную} рекурсии. При {\bf{явной}} – в теле подпрограммы существует вызов самой себя, при {\bf{косвенной}} – вызов осуществляется в подпрограммах, вызываемых из рассматриваемой.

Косвенная рекурсия требует предопределения forward:

\image {Recursion.jpg}{70}

{\bf Достоинства} 
\begin{enumerate}
\item Наглядное, понятное и компактное решение задачи.
\item Облегчает отладку.
\item Неизменяемость переменных.
\end{enumerate}

{\bf Недостатки}
\begin{enumerate}
\item Потребление памяти. 
\item Потребление процессорного времени.
\end{enumerate}

{\textit {Замечания:}}
\begin{enumerate}
\item Рекурсию предпочитают итерации, если рекурсия естественно отражает задачу и её результаты, т.е когда рекурсивный подход нагляден.
\item Если требуется повысить эффективность программы, то следует избегать использования рекурсий.
\end{enumerate}


\lstinputlisting[language=Pascal]{../Examples/b19_1.pas}

\lstinputlisting[language=Pascal]{../Examples/b19_2.pas}


%================================
%          Вопрос 20
%================================

\newpage\subsection{Адресация динамической памяти: понятие адреса, операции получения адреса и разыменования. Процедуры получения памяти и освобождения ее. Примеры. }

\begin{myquote}
    \hbook{212 - 222}
            
    \hprez{6}{2 - 13}
\end{myquote}

Минимальная адресуемая единица памяти большинства современных процессоров – {\bf байт}. Байты памяти нумеруют, начиная с нуля.
Непрерывный участок памяти, имеющий длину не более 64 КБ и начинающийся с адреса, кратного 16 (0,16,32, ), называют {\bf сегментом}. Адрес начала сегмента принимают за базу для всего сегмента. Адрес базы сегмента без последних четырех бит называют {\bf сегментным}. 
Сегментный адрес и смещение имеют размер по 16 бит (слово). Физический адрес, получаемый при их сложении с учетом отброшенных четырех 
бит (рис. 7.2), имеет размер 20 бит и может адресовать память объемом $2^{20}$ байт или 1 МБ.

\image {Address1.jpg}{100}
\image {Address2.jpg}{100}

Для хранения и работы с адресами переменных используются {\bf{указатели}}. Данные этого типа включают два поля word и хранят соответственно сегментный адрес и смещение.

Различают указатели: 

\begin{itemize}
\item {\bf{типизированные}} – адресующие данные конкретного типа;
\item {\bf{нетипизированные}} – не связанные с данными определенного типа.
\end{itemize}

Объявление типизированного указателя:

\image {Pointer.jpg}{30}

Объявление нетипизированного указателя: pointer

{\bf Взятие адреса}
 
\image{GetterAddr.jpg}{14}

{\bf Разыменовывание: }
Data\^ := <значение>;
\newpage
Управление выделением и освобождением памяти осуществляется посредством специальных процедур и функций:

\begin{enumerate}
\item Процедура {\bf New(var P: \^<тип>)} – выделяет память для размещения переменной, размер определяется типом указателя.
\item Процедура {\bf Dispose(var P: \^<тип>)} – освобождает выделенную память.
\item Процедура {\bf GetMem(var P: Pointer; Size: Integer)} – выделяет указанное количество памяти и помещает ее адрес в указатель.
\item Процедура {\bf FreeMem(var P: Pointer[; Size: Integer])} – освобождает выделенную память.
\item Функция {\bf SizeOf(X): Integer} – возвращает размер переменной в байтах.
\end{enumerate}



\lstinputlisting[language=Pascal]{../Examples/b20_1.pas}


%================================
%          Вопрос 21
%================================

\newpage\subsection{Списковые  структуры  данных.  Классификация  и  основные  приемы  работы  с  ними:  создание элемента, добавление элемента к списку, удаление элемента из списка. Область применения списковых структур данных. Пример. }

\begin{myquote}
    \hbook{223 - 237}
            
    \hprez{6}{14 - 30}
\end{myquote}

{\bf Список} – способ организации данных, предполагающий использование указателей для определения следующего элемента.

Элемент списка состоит из двух частей: {\bf информационной} и {\bf адресной}:
\begin{itemize}
\item {\bf Информационная часть} содержит поля данных.

\item {\bf Адресная} – включает от одного до n указателей, содержащих адреса следующих элементов. 

Количество связей, между соседними элементами списка определяет его {\bf связность}: односвязные, двусвязные, n-связные.
\end{itemize}

{\bf Основные приемы работы (на примере односвязного списка):}
{ {Подробнее на страницах 226 - 237 учебника.}}
\begin{itemize}
    \item {\bf Создание элемента}: для каждого элемента память выделяется динамически (процедура new).
    
    \item {\bf Добавление элемента к списку}:
    \begin{enumerate}
    \item Находим место вставки;

    \item Создаем новый элемент и в его адресное поле записываем указатель из адресного поля элемента, предшествующего вставке;

    \item В адресное поле предшествующего элемента записываем указатель на новый элемент;
    \end{enumerate}
    \item {\bf Удаление элемента из списка};
    \begin{enumerate}
        \item Находим место удаления;
        \item Сохраняем адрес следующего элемента;
        \item Освобождаем память;
        \item Заносим в указатель предшествующего элемента сохраненный адрес. 
    \end{enumerate}

\end{itemize}

\lstinputlisting[language=Pascal]{../Examples/b21_1.pas}


%================================
%          Вопрос 22
%================================

\newpage\subsection{Основы файловой системы: файл, каталог, полное имя файла, внутреннее представление 
информации в файле. Файловая переменная. Операции открытия и закрытия файлов. Примеры. }

\begin{myquote}
    \hbook{188 - 196}
            
    \hprez{5}{2 - 15}
\end{myquote}

{\bf Файл} – поименованная  последовательность элементов данных (компонентов файла), хранящихся, как правило, во внешней памяти. 

Как исключение данные файла могут не храниться, а вводиться с внешних устройств (ВУ), например клавиатуры или выводиться на ВУ, например экран.

Полное имя файла включает:

<Имя диска>:<Список имен каталогов><Имя файла>.<Расширение>

Имя файла в Windows составляют из строчных и прописных букв латинского и русского алфавитов, арабских цифр и некоторых специальных символов, например, символов подчеркивания «\_» или доллара «\$»

Расширение определяет тип хранящихся данных, например:

\begin{itemize}
	\item {\bf COM, EXE} – исполняемые файлы (программы);
	\item {\bf PAS, BAS, CPP} – исходные тексты программ на алгоритмических языках  ПАСКАЛЬ, БЭЙСИК и С++;
	\item {\bf BMP, JPG, PIC} – графические файлы (рисунки, фотографии); 
	\item {\bf WAV,MP3,WMA} – музыкальные файлы.
\end{itemize}

{\bf {внутреннее представление информации в файле}}

\image{file22.jpg}{100}

{\bf {Описание файловых переменных}}:

\begin{enumerate}
\item {\bf Типизированные файлы:}  	     file of <Тип компонента>,
    где  <Тип компонента> – любой тип данных, кроме файлового.
\item {\bf Текстовые файлы:}     text
\item {\bf Нетипизированные файлы:}   file
\end{enumerate}

Процедура Assign или AssignFile (Var f; st:string) – связывает файловую переменную f с файлом, имя которого указано в строке st.  
Если файл находится в текущем каталоге, то достаточно задать имя файла и его расширение. В противном случае необходимо указать полное имя файла.

{\bf Операция открытия файла}

При открытии файла необходимо задать направление передачи данных: запись или чтение. Кроме того текстовый файл можно открыть для добавления компонентов.

\begin{enumerate}
    \item Процедура {\bf ReSet(Var f)} – открывает файл для чтения данных. 
	Устанавливает указатель файла на первый компонент. Если файл не существует, выдается сообщение об ошибке.
    \item Процедура {\bf ReWrite(Var f)} – открывает файл для записи. 
	Если указанный файл существовал, то он уничтожается без выдачи предупреждения пользователю, иначе он создается и указатель устанавливается на начало.
    \item Процедура {\bf AppEnd(Var f:text)} – открывает текстовый файл для добавления данных. Указатель файла устанавливается на конец файла.
\end{enumerate}

{\bf Контроль операций ввода-вывода}

Функция IOResult:Word – возвращает код завершения операции ввода-вывода: 0 – если операция прошла нормально, код ошибки, если нет. Функция применяется при отключенном контроле операций ввода-вывода \{\$I-\}. 

{\bf Операция закрытия файла}

Процедура Close или CloseFile(Var f) - выполняет закрытие файла. При этом вновь созданный файл регистрируется в каталоге. Процедура закрытия файла обеспечивает вывод оставшихся компонентов из буфера в файл. Связь файловой переменной с файлом при закрытии сохраняется, поэтому при продолжении обработки повторно процедуру AssignFile() можно не выполнять. 

*По {\bf{способу доступа к компонентам}} файлы делятся на файлы прямого доступа и файлы
последовательного доступа. 
\begin{itemize}
    \item Файлы последовательного доступа считываются
от первой записи до последней по порядку;
    \item Файлы прямого доступа могут считывать определенную запись по
номеру.
\end{itemize}

\lstinputlisting[language=Pascal]{../Examples/b22_1.pas}

%================================
%          Вопрос 23
%================================

\newpage\subsection{Текстовые  файлы.  Внутреннее  представление  информации  в  файле.  Операции  над  файлами. Пример. }

\begin{myquote}
    \hbook{196 - 201}
            
    \hprez{5}{16 - 25}
\end{myquote}


{\bf {Текстовый файл}} – файл, компонентами которого являются символьные строки переменной длины, заканчивающиеся специальным маркером – маркером «Конец строки». 
 
{\bf {Внутреннее представление информации в файле}}:
\image{TextFile.jpg}{100}

{\bf {Операции над текстовыми файлами}}:
\begin{itemize}
\item Текстовые файлы используют для хранения и обработки символов, строк, символьных массивов. Числовые и логические данные при записи в текстовые файлы должны преобразовываться в символьные строки.
\item Текстовый файл можно открыть для записи, чтения и добавления записей в конец. Файл, открытый для записи, не может использоваться для чтения и наоборот. 
\end{itemize}

{\bf {Процедуры и функции обработки текстовых файлов}}: 

\begin{enumerate}
\item Функция EOLn([Var  f]): Boolean – возвращает TRUE, если во входном текстовом файле достигнут маркер конца строки; при отсутствии файловой переменной проверяется файл INPUT, связанный с клавиатурой.

\begin{itemize}
\item При работе с клавиатурой функция EOLn возвращает TRUE, если последним считанным был символ \#13. 
\item При работе с диском функция EOLn возвращает TRUE, если следующим считанным будет символ \#13.
\end{itemize}

\item Процедура Read([Var f:text;]v1,v2,...vn) – обеспечивает ввод символов, строк и чисел. При вводе чисел пробелы и символы табуляции игнорируются. Если файловая переменная не указана, то ввод осуществляется из файла INPUT.

\item Процедура ReadLn([Var f;][v1,v2,...,vn]) – осуществляет ввод символов, строк и чисел. После чтения последней переменной оставшаяся часть строки до маркера конца строки пропускается так, что следующее обращение к ReadLn или Read начинается с первого символа новой строки. 

\item Процедура Write([Var  f;]v1,v2, ...,vn ) – осуществляет вывод одного или более выражений типа CHAR, STRING, BOOLEAN, а также целого или вещественного типов. При выводе числовых значений последние преобразуются в символьное представление. Если файловая переменная не указана, то вывод осуществляется в файл OUTPUT.
    
\item Процедура WriteLn([Var f;][v1,v2, ...,vn]) – осуществляет вывод в текстовый файл. Если файловая переменная не указана, то вывод осуществляется в файл OUTPUT.

Выводимая строка символов завершается маркером конца строки. Если список вывода не указан, то в файл передается только маркер конца строки.
     
\item Функция SeekEOLn([Var f]):boolean – пропускает пробелы и знаки табуляции до маркера конца строки или до первого значащего символа и возвращает TRUE, при обнаружении маркера. Если файловая переменная не указана, то функция проверяет файл INPUT.

\item Функция SeekEOF([Var f]):boolean – пропускает все пробелы, знаки табуляции и маркеры конца строки до маркера конца файла или до первого значащего символа и возвращает TRUE при обнаружении маркера. Если файловая переменная отсутствует, то функция проверяет файл INPUT.
\end{enumerate}

\lstinputlisting[language=Pascal]{../Examples/b23_1.pas}


%================================
%          Вопрос 24
%================================

\newpage\subsection{Типизированные  файлы:  внутреннее  представление  информации  в  файле.  Операции  над 
файлами. Пример. }

\begin{myquote}
    \hbook{201 - 207}
            
    \hprez{5}{26 - 43}
\end{myquote}

{\bf Типизированный файл} – файл, все компоненты которого одного типа, заданного при объявлении файловой переменной. 
Компоненты хранятся на диске во внутреннем (двоичном) формате. При этом числа хранятся в формате, в котором над ними выполняются операции. 

{\bf{Внутреннее  представление  информации  в  файле}}:
\image{TypedFile.jpg}{90}

*Типизированные файлы могут быть созданы только программным путем.

Типизированный файл можно открыть для записи и чтения. Файл, открытый для записи, может использоваться для чтения. В файл, открытый для чтения, можно писать.  
Поскольку размер компонентов одинаков, принципиально возможен не только последовательный, но и {\bf{прямой доступ}} (о типах доступа к компонентам файла подробнее в п.22). 

{\bf Процедуры и функции обработки типизированных файлов}

\begin{enumerate}
\item Процедура {\bf Read(Var f; c1,c2,...,cn)} – осуществляет чтение компонентов типизированного файла. Список ввода содержит одну или несколько переменных того же типа, что и компоненты файла. Если файл исчерпан, обращение к процедуре вызывает ошибку ввода-вывода.

\item Процедура {\bf Write(Var f; c1,c2,...,cn)} – осуществляет запись компонентов в типизированный файл.  Список вывода содержит одно или более выражений того же типа, что и компоненты файла.

\item Процедура {\bf Seek(Var f; numcomp:longint)} – осуществляет установку указателя файла на компонент с номером numcomp.

\item Функция {\bf FileSize(Var f):longint} – возвращает количество компонентов файла. Может использоваться для установки на конец файла совместно с Seek():(f));

\item Функция {\bf FilePos(Var f):longint} –  возвращает порядковый номер компонента, который будет обрабатываться следующим.

\item  Процедура {\bf Truncate(Var f)} – выполняет «усечение» файла
\end{enumerate}

%================================
%          Вопрос 25
%================================

\newpage\subsection{Нетипизированные  файлы.  Внутреннее  представление  информации  в  файле.  Операции 
над файлами. Пример. }

\begin{myquote}
    \hbook{207 - 211}
            
    \hprez{5}{44 - 49}
\end{myquote}

{\bf{Нетипизированными}} называют файлы, объявленные без указания типа компонентов.

*Неипизированные файлы могут быть созданы только программным путем.

Операции чтения и записи с такими файлами осуществляются блоками, что позволяет организовать высокоскоростной обмен данными между диском и памятью. Отсутствие типа делает эти файлы совместимыми с любыми другими, однако обрабатывать такие файлы существенно сложнее.

Нетипизированные файлы, как и типизированные, допускают организацию {\bf{прямого доступа}}, но к записям.

Нетипизированный файл можно открыть для записи и для чтения:
\begin{itemize}
         \item ReSet(Var f;[recsize:word]);
         \item ReWrite(Var f;[recsize:word]);
\end{itemize}

, где recsize – размер записи файла в байтах. Длину записи задают кратной 512 байт, например:  1024, 2048. Если длина записи не указана, она принимается равной 128.

Процедуры и функции обработки нетипизированных файлов:
\begin{enumerate}
    \item Процедура BlockRead(Var f:file; Var buf;Count:word[;Var res:word])– осуществляет чтение блока записей из файла в буфер buf. 
Параметр res будет содержать количество фактически обработанных записей. Если последняя запись – неполная, то значение параметра res ее не учтет. 
    \item Процедура BlockWrite(Var f:file;Var buf;Count:word[;Var res:word])– осуществляет запись блока из буфера buf в файл.
\end{enumerate}

\lstinputlisting[language=Pascal]{../Examples/b25_1.pas}


%================================
%          Вопрос 26
%================================

\newpage\subsection{Классы консольного режима среды Lazarus: описание классов, поля и методы, объявление 
объектов класса, доступ к полям и методам объекта, ограничение доступа. Пример. }

\begin{myquote}
    \hbook{303 - 321}
            
    \hprez{7}{17 - 25}
\end{myquote}

{\bf Класс} – это структурный тип данных, который включает описание {\bf {полей данных}}, а также процедур и функций, работающих с этими полями данных. Применительно к классам такие процедуры и функции получили название {\bf методов}.

	 – это шаблон кода, по которому создается какой-то объект

     – это тип данных, задающий реализацию некоторой абстракции данных (сущности), характерной для моделируемой предметной области. 


{\bf {Описание классов}}
\image {ClassDes.jpg} {70}
\image {MethodDes.jpg} {75}

{\bf Объект-переменная или объект класса} – переменная типа «класс». Описав класс, мы можем объявить любое количество объектов этого 
класса, причем можно объявить отдельные объекты, массивы объектов и указатели на объекты данного класса.

\begin{lstlisting}[language=Pascal]
type class_identifier = object; {NOT CLASS!!!}
   private
      field1 : field_type1;  
      field2 : field_type2;  
        ...
   
   public
      constructor create(...);
      procedure proc1;  
      function f1(): function_type;
end;  

constructor class_identifier.create(...);
...
procedure class_identifier.proc1;  
...

var classvar : class_identifier;
\end{lstlisting}

\vspace*{10pt}

{\bf модификаторы доступа к полям (основные):}
\begin{itemize}
\item {\bf private} – доступ только в контексте класса.

\item {\bf protected} – доступ только в контексте класса и классов-наследников.

\item {\bf Public} – доступ есть всегда, когда доступен сам класс.
\end{itemize}


%================================
%          Вопрос 27
%================================

\newpage\subsection{Классы консольного режима  среды  Lazarus: Способы инициализации полей. Неявный параметр Self. Пример. }

\begin{myquote}
    \hbook{314 - 319}
            
    \hprez{7}{18, 20 - 22}
\end{myquote}

{\bf {Способы инициализация полей:}}
\begin{enumerate}
\item Инициализация полей прямой записью в поле:

\begin{lstlisting}[language=Pascal]
A.length:=3.5;
A.width:=5.1;
\end{lstlisting}

\item Инициализация при объявлении объекта: 
\begin{lstlisting}[language=Pascal]
Var A:TRoom = (length:3.5; width:5.1);
\end{lstlisting}

\item Инициализация посредством метода:
\begin{lstlisting}[language=Pascal]
procedure Init(l,w:single);
Procedure TRoom.Init;
Begin  length:=l;  width:=w;  End;
\end{lstlisting}

\end{enumerate}

Любой метод (при его вызове) неявно получает {\bf{параметр Self}} – ссылку (адрес) на 
поля объекта (вызывающего этот метод), и обращение к полям происходит через это имя.


%================================
%          Вопрос 28
%================================

\newpage\subsection{Процедурная и объектная декомпозиция. Диаграммы классов. Отношения между классами. Примеры. }

\begin{myquote}
    \hbook{303 - 312, 327 - 344}
            
    \hprez{7}{12, 26 - 55}
\end{myquote}

{\bf {Процедурная декомпозиция}} - структурное программирование: разбиение программы на подпрограммы, решающие отдельные подзадачи.

{\bf {Объектная декомпозиция}} - в предметной области задачи выделяют отдельные элементы, поведение которых программно моделируется, а затем, уже из готовых объектов собирается сложная программа.

{\bf {Диаграмма классов (англ. class diagram)}} — диаграмма, демонстрирующая общую структуру иерархии классов системы, их коопераций, атрибутов (полей), методов, интерфейсов и взаимосвязей между ними.

Описание класса на диаграмме:
\image {diag.jpg} {50}

{\bf{Отношения между классами:}}
\begin{itemize}
\item{\bf {Наследование}} – механизм конструирования новых более сложных производных классов из уже имеющихся базовых посредством добавления полей и методов. 

Описание наследования на диаграмме:
\image{Inheritance.jpg}{135}

\item{\bf {Композиция}} – включение объектов одного класса в объекты другого. Реализуется механизмом поддержки объектных полей.

Описание композиции на диаграмме:
\image{Composition.jpg}{160}

\item{\bf {Наполнением или агрегацией}} называют такое отношение между классами, при котором точное количество объектов одного класса, включаемых в 
другой класс, не ограничено и может меняться от О до достаточно больших 
значений. Физически наполнение реализуется с использованием указателей 
на объекты.

\image{Agregation.jpg}{90}


\item{\bf{Простой (статический) полиморфизм}} – механизм переопределения методов при наследовании, при котором связь метода с объектом выполняется на этапе компиляции (раннее связывание).

*Раннее связывание – адрес метода определяется на этапе компиляции по объявленному типу переменной.

\item {\bf{Сложный полиморфизм}} - механизм, используемый, если при вызове переопределенного метода необходимо уточнить, какой метод должен быть подключен: метод 
родителя или метод потомка, так как объект, для которого вызывается переопределенный метод, может быть как объектом класса родителя, так и объектом класса потомка. В этом случае нужный метод определяется на этапе выполнения программы (позднее связывание), когда тип объекта точно известен.

*Позднее связывание – адрес метода определяется на этапе выполнения по фактическому типу объекта через таблицу виртуальных методов класса, адрес которой хранится в объекте.

\newpage
{\bf{Различие раннего и позднего связывания (слева - раннее, справа - позднее связывание)}}
\image{EarlyLater.jpg} {190} 
\end{itemize}

{\bf{Для организации сложного полиморфизма необходимо:}}

\begin{enumerate}
\item переопределяемые методы описать служебным словом {\bf{virtual}}; 
\item к методам класса с виртуальными полиморфными методами добавить специальный метод-процедуру – {\bf{конструктор}}, в котором служебное слово procedure заменено служебным словом constructor;
\item вызвать конструктор прежде, чем произойдет первое обращение к виртуальным полиморфным методам.  
Подключение осуществляется с исполь	зованием таблицы виртуальных методов (ТВМ), которая создается при выполнении конструктора.
\end{enumerate}


{\bf{3 случая обязательного использования сложного полиморфизма:}}
\begin{enumerate}
\item Если наследуемый метод для объекта производного класса вызывает метод, переопределенный в производном классе.
\item Если объект производного класса через указатель базового класса обращается к методу, переопределенному производным классом.
\item Если процедура вызывает переопределенный метод для объекта производного класса, переданного в процедуру через параметр-переменную, описанный как объект базового класса («процедура с полиморфным объектом»). 
\end{enumerate}

{\bf{Свойства виртуальных методов класса:}}
\begin{enumerate}
    \item позднее связывание требует построения ТВМ, а следовательно больше памяти;
    \item вызов виртуальных полиморфных методов происходит через ТВМ, а следовательно медленнее;
    \item список параметров одноименных виртуальных полиморфных методов должен совпадать, а статических полиморфных – не обязательно;
    \item статический полиморфный метод не может переопределить виртуальный полиморфный метод.  
\end{enumerate}



%================================
%          Вопрос 29
%================================

\newpage\subsection{Динамические объекты и объекты с динамическими полями в консольном режиме среды 
Lazarus. Примеры. }

\begin{myquote}
    \hbook{348 - 353}
            
    \hprez{7}{56 - 62}
\end{myquote}

{\bf{Создание полиморфных объектов:}}

Функция New(<Тип указателя>[,<Вызов конструктора>]) – возвращает адрес размещенного и, при вызове конструктора, сконструированного объекта. Если вызов конструктора в New отсутствует, то после выделения памяти необходим вызов конструктора. 

{\bf{Деструктор}} – метод класса, который используется для корректного уничтожения полиморфного объекта, содержащего невидимое поле. Деструктор можно использовать для освобождения памяти динамических полей и переопределять при наследовании.

{\bf{Уничтожение полиморфных объектов:}}

Процедура Dispose(<Указатель>[,<Вызов деструктора>]) – если есть вызов деструктора, то устанавливается размер полиморфного объекта и корректно освобождается память

{\bf{Динамические поля}} в статических и динамических полиморфных 
объектах:

Если при разработке классов для реализации полиморфных объектов используют динамические поля (объектные или нет), то запрос памяти под них обычно помещают в конструктор, а освобождение памяти - в деструктор. Тогда при 
уничтожении объекта автоматически освобождается память, отведенная для его полей.




%================================
%          Вопрос 30
%================================

\newpage\subsection{Технология  событийного  программирования.  События  операционной  системы,  сообщения и события Lazarus. Основные события Lazarus. Примеры.}

\begin{myquote}
    \hbook{391 - 412}
            
    \hprez{8}{2 - 18}
\end{myquote}

{\bf{Событийно-ориентированное программирование (СОП)}} – парадигма программирования, в которой выполнение программы определяется событиями – действиями пользователя (мышь, клавиатура, сенсорный экран и тд), сообщениями других программ и потоков, событиями операционной системы.

{\bf{События операционной системы}} – любые изменения состояния ОС: запуск системы (ПК), вход в систему любого пользователя, любые запускаемые процессы и тд.

{\bf{Порядок обработки событий ОС:}}
\begin{enumerate}
    \item В системе происходит событие, например, пользователь передвинул мышь или нажал на клавишу клавиатуры, в результате генерируется сообщение об этом событии – сообщение ОС. 
    \item Сообщение ОС диспетчируется конкретному приложению.
    \item В приложении сообщение передается активному компоненту (окну или управляющему элементу). 
    \item Метод обработки сообщения ОС компонента инициирует заранее предусмотренные события среды.
    \item Если в приложении предусмотрен соответствующий обработчик события среды, то он вызывается, если нет – то продолжается обработка сообщения ОС.     
\end{enumerate}

{\bf{Основные события Lazarus}}
\begin{enumerate}
\item При изменении состояния формы:

OnCreate – в начальной стадии создания формы - используется при необходимости задания параметров (цвет или размер);

OnActivate – при получении формой фокуса ввода (окно становится активным и ему адресуется весь ввод с клавиатуры);

OnShow – когда форма (окно) становится видимой;

OnPaint – при необходимости нарисовать или перерисовать форму;

OnResize - при изменении размеров формы на экране;

OnDeactivate – при потере формой фокуса ввода (окно становится неактивным);

OnHide – при удалении формы с экрана (окно становится невидимым); 

OnCloseQuery – при попытке закрыть форму - обычно используется для создания 
запроса-подтверждения необходимости закрытия окна;

OnClose – при закрытии формы;

OnDestroy – при уничтожении формы;
\item От клавиатуры и мыши:

OnKeyPressed – при нажатии клавиш, которым соответствует код ANSI;

OnKeyDown, OnKeyUp – при нажатии и отпускании любых клавишI;

OnClick, OnDblClick – при обычном и двойном нажатии клавиш мыши;

OnMouseMove – при перемещении мыши (многократно);

OnMouseDown, OnMouseUp – при нажатии и отпускании клавиш мыши;
\item При перетаскивании объекта мышью:

OnDragDrop – в момент опускания объекта на форму;

OnDragOver – в процессе перетаскивания объекта над формой (многократно);
\item Другие:

OnHelp – при вызове подсказки;

OnChange – при изменении содержимого компонент.
\end{enumerate}


\newpage\section{Практическая часть.}
\subsection{Задача 1.}
{\bf Условие:} даны два объекта: обеденный стол и письменный стол с тумбой. Оба объекта должны отвечать на запрос о площади поверхности, а письменный стол – еще и на запрос об объеме ящиков тумбы. Разработать классы для реализации заданных объектов. Определить отношение между классами и построить диаграмму классов. Описать полученные классы и написать тестирующую программу. 

{\textit {Указание}}. При решении задачи возможно использование, как наследования, так и композиции. При принятии решения следует учесть, что и оба объекта – столы и, следовательно, по сути, имеют общие характеристики.


{\bf Решение}

\begin{enumerate}
\item Класс "обеденный стол"\ будет включать:
\begin{itemize}
    \item Параметры стола (длина, ширина, высота);
    \item Методы для инициализации полей и расчета площади стола.
\end{itemize}

\item Класс "письменный стол с тумбой"\ можно {\bf наследовать} от класса "обеденный стол"\, с добавлением новых полей (для хранения количества ящиков в тумбе и их параметров: высоты, длины и ширины) и методов (для инициализации полей и для расчета объема ящиков тумбы). 
\end{enumerate}

{\centering {\bf {Диаграмма классов}}}

\image{EX1diagNEW.jpg}{260}

{\centering {\bf {Код программы}}}

\lstinputlisting[language=Pascal]{../Examples/a1_1.pas}

\newpage\subsection{Задача 2.}
{\bf Условие:} даны два объекта: полка и стеллаж. Объекты должны отвечать на запрос о высоте, а также 
объеме рабочего пространства.

Разработать классы для реализации заданных объектов. Определить отношение между классами и 
построить диаграмму классов. Описать полученные классы и написать тестирующую программу. 


{\bf Решение}

\begin{enumerate}
\item Класс "полка"\ будет включать:
\begin{itemize}
    \item Параметры полки (длина, ширина, высота);
    \item Методы для инициализации полей, возврата значения высоты и расчета объема рабочего пространства. 
\end{itemize}

\item Класс "стеллаж"\ будет включать:
\begin{itemize} 
    \item Один объект класса "полка"\ (то есть используется {\bf композиция}) 
    и количество полок в стеллаже. 
    \item Методы для инициализации полей, расчета значения высоты и расчета объема рабочего пространства. 
\end{itemize}
\end{enumerate}

{\centering {\bf {Диаграмма классов}}}

\image{EX2diagNEW.jpg}{140}


{\centering {\bf {Код программы}}}

\lstinputlisting[language=Pascal]{../Examples/a1_2.pas}

\vspace*{250pt}
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\vspace*{20pt}
{\begin{myquote2}
\begin{center}
    \bf \begin{small}{
    Вот и кончился наш прекрасный файл! Спасибо, что прочитали его.

    Да прибудет с вами полиморфизм и стек!

    Хорошего зимнего настроения и отличных оценок)

}\end{small}\end{center}
\begin{flushright}
    \textit{Риторический терзает душу нам вопрос\\
    Как пропылесосить пылесос}
    \end{flushright}
\end{myquote2}}

\vspace*{20pt}
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\vspace*{20pt}
\newpage
\let\clearpage\relax
\end{document}




% Привет! Мы подготовили файлик для подготовки к экзамену по ОП. Он доступен по ссылке:https://github.com/pluttan/BMSTU-1/blob/master/ОП/Подготовка%20к%20экзамену/examOP.pdf. Файл разрабатывался по учебнику (учебникам) Галины Сергеевны и по ее презентациям. В подтверждение этого и для вашей дополнительной практики сюда добавлены ссылки на презентации и книгу. Файл полностью бесплатен, но вы можете приобрести его книжную версию (реально буклет), она очень удобна относительно электронной версии (жду в ЛС). Удачного бота и хороших оценок (может быть скоро выйдут еще файлики...).